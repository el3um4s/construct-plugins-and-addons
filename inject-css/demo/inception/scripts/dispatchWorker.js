"use strict";self.inputPort=null,self.jobQueue=[],self.jobWorkers=[];class JobWorker{constructor(a,b){this._port=a,this._number=b,this._isBusy=!1,this._port.onmessage=(a)=>this._OnMessage(a.data)}ImportScripts(a){this._port.postMessage({"type":"_import_scripts","scripts":a})}SendBlob(a,b){this._port.postMessage({"type":"_send_blob","blob":a,"id":b})}SendJob(a){if(this._isBusy)throw new Error("already busy");this._isBusy=!0,this._port.postMessage(a,a["transferables"])}IsBusy(){return this._isBusy}GetNumber(){return this._number}_OnMessage(a){const b=a["type"];return"done"===b?void this._OnJobDone():void console.error("unknown message from worker '"+b+"'")}_OnJobDone(){this._isBusy=!1,this.MaybeStartNextJob()}MaybeStartNextJob(){if(!this._isBusy){const a=this._FindAvailableJob();if(-1!==a){const b=self.jobQueue[a],c=b["isBroadcast"];c?(b["doneFlags"][this._number]=!0,b["doneFlags"].every((a)=>a)&&self.jobQueue.splice(a,1)):self.jobQueue.splice(a,1),this.SendJob(b)}}}_FindAvailableJob(){for(let a=0,b=self.jobQueue.length;a<b;++a){const b=self.jobQueue[a];if(!b["isBroadcast"]||!b["doneFlags"][this._number])return a}return-1}}let number=0;function AddJobWorker(a){const b=new JobWorker(a,number++);self.jobWorkers.push(b),b.MaybeStartNextJob()}function CancelJob(a){for(let b=0,c=self.jobQueue.length;b<c;++b)if(self.jobQueue[b].jobId===a)return void self.jobQueue.splice(b,1)}self.addEventListener("message",(a)=>{const b=a.data,c=b["type"];"_init"===c?(self.inputPort=b["in-port"],self.inputPort.onmessage=OnInputPortMessage):"_addJobWorker"===c&&AddJobWorker(b["port"])});function OnInputPortMessage(a){const b=a.data,c=b["type"];if("_cancel"===c)return void CancelJob(b.jobId);if("_import_scripts"===c){for(const a of self.jobWorkers)a.ImportScripts(b["scripts"]);return}if("_send_blob"===c){for(const a of self.jobWorkers)a.SendBlob(b["blob"],b["id"]);return}self.jobQueue.push(b),b["isBroadcast"]&&(b["doneFlags"]=Array(self.jobWorkers.length).fill(!1),b["transferables"]=[]);for(const b of self.jobWorkers)b.MaybeStartNextJob()}